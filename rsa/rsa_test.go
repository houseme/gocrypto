package rsa

import (
	"testing"

	"github.com/houseme/gocrypto"
)

type RSACryptTest struct {
	data       string
	encodeType gocrypto.Encode
	hashType   gocrypto.Hash
}

func TestRSACrypt(t *testing.T) {
	var secretInfo = Secret{
		PublicKey:          "MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAyoiAraTnAbCoqGVOKugFDM2/ms2szXmb3zTOU3ByicH/XPZqy7Eougbs8OQQIoNW4xKw8PNyWf0lfr90qBfPj27INn6N7umVmbHCNCKkQ4frPn46xesw1ywtc2GhOEzZlC8ajlnzBUkj5FJZcrNjXfFmfsQcFQP0g/o/3CAUpk1BXFXt7eZsaYdyn0m7fMoyFt1wlF8egQeGYYE98vtKsvrII51HK8vOEf+5VXU4UZxGfvyzS3A8kuNEkKEh1n9mazjfPBT0KGSiOGh7Nugks+jjfswSgXRK/b2eP3fS7U625rbS798pKxnoS2E0Pgpzdk5fWoNgAlG/n2F9oI2/kQIDAQAB",
		PublicKeyDataType:  gocrypto.Base64,
		PrivateKey:         "MIIEowIBAAKCAQEAyoiAraTnAbCoqGVOKugFDM2/ms2szXmb3zTOU3ByicH/XPZqy7Eougbs8OQQIoNW4xKw8PNyWf0lfr90qBfPj27INn6N7umVmbHCNCKkQ4frPn46xesw1ywtc2GhOEzZlC8ajlnzBUkj5FJZcrNjXfFmfsQcFQP0g/o/3CAUpk1BXFXt7eZsaYdyn0m7fMoyFt1wlF8egQeGYYE98vtKsvrII51HK8vOEf+5VXU4UZxGfvyzS3A8kuNEkKEh1n9mazjfPBT0KGSiOGh7Nugks+jjfswSgXRK/b2eP3fS7U625rbS798pKxnoS2E0Pgpzdk5fWoNgAlG/n2F9oI2/kQIDAQABAoIBAF378hqiR0CVhe5+9EMc4BsM7zka8HF5WUe+7W/y4nPivmmZP/29/DQ3OoSekI4zfIJrDgkCL7JqspeaqLvIMN1Sfz4qhBq18mIcBw7CdI+R5yxcz1FAzq1LJtxAFdxWbTFCmoQsYYW2Zx1wyWlcrWPOvc1dm9p0t2b3HeM8T9jLdY+D0Bm9zmAS0nwTuDBxYS77DB9Ncl6pWLLd197/5IoN1/nunFuzpkiwMPI9RF7lgrnUthc/1Gfnylz5/tXCiQsEVSbAdbMXt9nsV0RgVeMcPq/aUqTMLS2lIV8JySWDrRQi4yPHU0hIjcp6ggo53YMuncJZweI/wwkJexojz0ECgYEA5QzRObpU0CryfJ7qa97/USIKHbvl6PuQG9OLyUeP9bG0edidQhUrR4EZwjIl73O8CTJ0bB24wAKZZEOK3eJeqG/N0q+CiD83ygr8pSZzpE1xvqQp32IgXtgvm7/UmT8cfAp05Z3bF4jcA8uXwodBz4NsVGijlO78PsCooLsArM0CgYEA4lz5pXDEN3w5JwkbspLnUSUS738hne8YM0PchCaww+8sXLS9GLL2CHcvwh6Tv9Mee7r6SdbDI73x118y68WEDDhidiYZCLhXJN2v12ezJOMqH5m9wVJzQOGNv6kPV1EW1WlWxoJQGxCdzbZMLxtTbyTZe3+iAVG++8u6NWMV3dUCgYA1dm1rnQto321kGy+6Z/2OMXTNBeufGwDDDfilzZdTkNwASMhEAW7trLuXcV8bahcsymMUTUevQawOFBnYupq/lAEluSOtq5vZBAF+huAdLJptFiJT6rKFkM5j+z2jW3DJnyMz6UmXT7GTDTVqCWoaBqIFfbsY60NjXlK92YhJzQKBgQDWfQjktbSHasLw9RV0oPRklD+cBhfBgfOpZ+0En3CxR+j+MxhW1gSBQwZS5wxTIGXrEeHlo4UmUe5diExE0dRsi+ToVPM1qw6P1SuwbQd3tXSNmu0NyOWCnfblm/j4YNLFB1p9IK9s5dLRQKJxpG/ribw15FuK6n2QM5vOyIPIvQKBgE5PUzRUCCVsjKAxZOfaZQatMbSzAUSB3bNmUw+F3pDq8ibs6XXvtySowG2femlPDNL7mDMuUc9kYrtTFTQNrEsQGB55wBopX3UxzRjpXJoAQ/d+RPdrSJC7xJyu+URoFI6ae0I3bx1BzjctYU0Rv5DUh+j9leMH5N2S9vHb+vqu",
		PrivateKeyType:     gocrypto.PKCS1,
		PrivateKeyDataType: gocrypto.Base64,
	}
	handle := NewRSACrypt(secretInfo)
	var rsaTests = []RSACryptTest{
		{
			"test",
			gocrypto.HEX,
			gocrypto.MD5,
		},
		{
			"base64",
			gocrypto.Base64,
			gocrypto.SHA256,
		},
		{
			"01234567890123456789012345678901234567890123456789012",
			gocrypto.String,
			gocrypto.SHA1,
		},
	}
	for _, rsaTest := range rsaTests {
		// encrypt data & encode result
		encrypt, err := handle.Encrypt(rsaTest.data, rsaTest.encodeType)
		if err != nil {
			t.Fatalf("encrypt error : %v", err)
		}
		// decrypt encrypted & encoded data
		decrypt, err := handle.Decrypt(encrypt, rsaTest.encodeType)
		if err != nil {
			t.Fatalf("decrypt error : %v", err)
		}
		if decrypt != rsaTest.data {
			t.Fatalf("decrypt get result %s , want get %s ", decrypt, rsaTest.data)
		}
		// sign data with digest algorithm & encode result
		sign, err := handle.Sign(rsaTest.data, rsaTest.hashType, rsaTest.encodeType)
		if err != nil {
			t.Fatalf("sign error : %v", err)
		}
		// verify data that signed with digest algorithm & encoded whether match original data
		verifySign, err := handle.VerifySign(rsaTest.data, rsaTest.hashType, sign, rsaTest.encodeType)
		if err != nil {
			t.Fatalf("verifySign error : %v", err)
		}
		if !verifySign {
			t.Fatal("verifySign result failed")
		}
		encrypt, err = handle.EncryptByPriKey(rsaTest.data, rsaTest.encodeType)
		if err != nil {
			t.Fatalf("encrypt error : %v", err)
		}
		decrypt, err = handle.DecryptByPublic(encrypt, rsaTest.encodeType)
		if err != nil {
			t.Fatalf("decrypt error : %v", err)
		}
		if decrypt != rsaTest.data {
			t.Fatalf("decrypt get result %s , want get %s ", decrypt, rsaTest.data)
		}
	}
}

func BenchmarkRSACrypt(t *testing.B) {
	for i := 0; i < t.N; i++ {
		var secretInfo = Secret{
			PublicKey:          "MIIBIjANBgkqhkiG9w0BAQEFAAOCAQ8AMIIBCgKCAQEAyoiAraTnAbCoqGVOKugFDM2/ms2szXmb3zTOU3ByicH/XPZqy7Eougbs8OQQIoNW4xKw8PNyWf0lfr90qBfPj27INn6N7umVmbHCNCKkQ4frPn46xesw1ywtc2GhOEzZlC8ajlnzBUkj5FJZcrNjXfFmfsQcFQP0g/o/3CAUpk1BXFXt7eZsaYdyn0m7fMoyFt1wlF8egQeGYYE98vtKsvrII51HK8vOEf+5VXU4UZxGfvyzS3A8kuNEkKEh1n9mazjfPBT0KGSiOGh7Nugks+jjfswSgXRK/b2eP3fS7U625rbS798pKxnoS2E0Pgpzdk5fWoNgAlG/n2F9oI2/kQIDAQAB",
			PublicKeyDataType:  gocrypto.Base64,
			PrivateKey:         "MIIEowIBAAKCAQEAyoiAraTnAbCoqGVOKugFDM2/ms2szXmb3zTOU3ByicH/XPZqy7Eougbs8OQQIoNW4xKw8PNyWf0lfr90qBfPj27INn6N7umVmbHCNCKkQ4frPn46xesw1ywtc2GhOEzZlC8ajlnzBUkj5FJZcrNjXfFmfsQcFQP0g/o/3CAUpk1BXFXt7eZsaYdyn0m7fMoyFt1wlF8egQeGYYE98vtKsvrII51HK8vOEf+5VXU4UZxGfvyzS3A8kuNEkKEh1n9mazjfPBT0KGSiOGh7Nugks+jjfswSgXRK/b2eP3fS7U625rbS798pKxnoS2E0Pgpzdk5fWoNgAlG/n2F9oI2/kQIDAQABAoIBAF378hqiR0CVhe5+9EMc4BsM7zka8HF5WUe+7W/y4nPivmmZP/29/DQ3OoSekI4zfIJrDgkCL7JqspeaqLvIMN1Sfz4qhBq18mIcBw7CdI+R5yxcz1FAzq1LJtxAFdxWbTFCmoQsYYW2Zx1wyWlcrWPOvc1dm9p0t2b3HeM8T9jLdY+D0Bm9zmAS0nwTuDBxYS77DB9Ncl6pWLLd197/5IoN1/nunFuzpkiwMPI9RF7lgrnUthc/1Gfnylz5/tXCiQsEVSbAdbMXt9nsV0RgVeMcPq/aUqTMLS2lIV8JySWDrRQi4yPHU0hIjcp6ggo53YMuncJZweI/wwkJexojz0ECgYEA5QzRObpU0CryfJ7qa97/USIKHbvl6PuQG9OLyUeP9bG0edidQhUrR4EZwjIl73O8CTJ0bB24wAKZZEOK3eJeqG/N0q+CiD83ygr8pSZzpE1xvqQp32IgXtgvm7/UmT8cfAp05Z3bF4jcA8uXwodBz4NsVGijlO78PsCooLsArM0CgYEA4lz5pXDEN3w5JwkbspLnUSUS738hne8YM0PchCaww+8sXLS9GLL2CHcvwh6Tv9Mee7r6SdbDI73x118y68WEDDhidiYZCLhXJN2v12ezJOMqH5m9wVJzQOGNv6kPV1EW1WlWxoJQGxCdzbZMLxtTbyTZe3+iAVG++8u6NWMV3dUCgYA1dm1rnQto321kGy+6Z/2OMXTNBeufGwDDDfilzZdTkNwASMhEAW7trLuXcV8bahcsymMUTUevQawOFBnYupq/lAEluSOtq5vZBAF+huAdLJptFiJT6rKFkM5j+z2jW3DJnyMz6UmXT7GTDTVqCWoaBqIFfbsY60NjXlK92YhJzQKBgQDWfQjktbSHasLw9RV0oPRklD+cBhfBgfOpZ+0En3CxR+j+MxhW1gSBQwZS5wxTIGXrEeHlo4UmUe5diExE0dRsi+ToVPM1qw6P1SuwbQd3tXSNmu0NyOWCnfblm/j4YNLFB1p9IK9s5dLRQKJxpG/ribw15FuK6n2QM5vOyIPIvQKBgE5PUzRUCCVsjKAxZOfaZQatMbSzAUSB3bNmUw+F3pDq8ibs6XXvtySowG2femlPDNL7mDMuUc9kYrtTFTQNrEsQGB55wBopX3UxzRjpXJoAQ/d+RPdrSJC7xJyu+URoFI6ae0I3bx1BzjctYU0Rv5DUh+j9leMH5N2S9vHb+vqu",
			PrivateKeyType:     gocrypto.PKCS1,
			PrivateKeyDataType: gocrypto.Base64,
		}
		handle := NewRSACrypt(secretInfo)
		var rsaTests = []RSACryptTest{
			{
				"test",
				gocrypto.HEX,
				gocrypto.MD5,
			},
			{
				"base64",
				gocrypto.Base64,
				gocrypto.SHA256,
			},
			{
				"01234567890123456789012345678901234567890123456789012",
				gocrypto.String,
				gocrypto.SHA1,
			},
		}
		for _, rsaTest := range rsaTests {
			// encrypt data & encode result
			encrypt, err := handle.Encrypt(rsaTest.data, rsaTest.encodeType)
			if err != nil {
				t.Fatalf("encrypt error : %v", err)
			}
			// decrypt encrypted & encoded data
			decrypt, err := handle.Decrypt(encrypt, rsaTest.encodeType)
			if err != nil {
				t.Fatalf("decrypt error : %v", err)
			}
			if decrypt != rsaTest.data {
				t.Fatalf("decrypt get result %s , want get %s ", decrypt, rsaTest.data)
			}
			// sign data with digest algorithm & encode result
			sign, err := handle.Sign(rsaTest.data, rsaTest.hashType, rsaTest.encodeType)
			if err != nil {
				t.Fatalf("sign error : %v", err)
			}
			// verify data that signed with digest algorithm & encoded whether match original data
			verifySign, err := handle.VerifySign(rsaTest.data, rsaTest.hashType, sign, rsaTest.encodeType)
			if err != nil {
				t.Fatalf("verifySign error : %v", err)
			}
			if !verifySign {
				t.Fatal("verifySign result failed")
			}
			encrypt, err = handle.EncryptByPriKey(rsaTest.data, rsaTest.encodeType)
			if err != nil {
				t.Fatalf("encrypt error : %v", err)
			}
			decrypt, err = handle.DecryptByPublic(encrypt, rsaTest.encodeType)
			if err != nil {
				t.Fatalf("decrypt error : %v", err)
			}
			if decrypt != rsaTest.data {
				t.Fatalf("decrypt get result %s , want get %s ", decrypt, rsaTest.data)
			}
		}
	}
}
